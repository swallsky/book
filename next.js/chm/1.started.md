### Next.js 介绍

#### Next.js是什么

> Next.js是一个用于构建全栈Web应用程序的React框架。它提供了一种简单而高效的方式来构建服务器端渲染(SSR)和静态网站(SSG)应用程序。它是由zeit公司开发的，一个开源项目，拥有广泛的社区 支持和丰富的插件生态系统。

##### 主要特点

1. 服务器端渲染(SSR): Next.js支持服务器端渲染，这使得应用程序在服务器上预先渲染，从而提高页面加载速度和搜索引擎优化(SEO)。Next.js提供了内置的API和钩子，使开发能够轻松地实现SSR。

2. 静态网站生成(SSG)：Next.js还支持静态网站生成，这是一种构建网站的新方法，它充许开发人员在构建时预先生成静态页面。这种方法可以提高性能和可扩展性，并且不需要任何服务器端渲染。

3. 集成API：Next.js充许将API集成到应用程序中，从而提供更好的数据管理和安全性。它支持Auth、Netlify、Algolia等。

4. 自动代码分割：Next.js通过自动代码分割提供更好的应用程序性能。它可以将JavaScript代码拆分成多个小块，以减少初始加载时间和带宽消耗。

5. 热模块替换(HMR)：Next.js支寺热模块替换，在开发过程中更新已加载模块的技术。帮助开发时，更快地迭代和测试代码。

6. 数据预取：Next.js提供了一种内置的方法来预取数据，可以预先加载和缓存数据，从而提高应用程序的性能和响应速度。

7. 自定义页面路由：基于文件系统的路由，构建在服务器组件之上，支持布局、嵌套路由、加载状态、错误处理等。

8. 国际化：Next.js支持多语言和国际化，可以根据不同地区和语言的用户自动切换。

9. 插件生态系统：Next.js具有丰富的插件生态系统，提供了许多现成的插件来扩展其功能。

10. 与其他库和框架集成：Next.js可以与其他流的库和框架集成，如Formik、GraphQL、React Native等。

#### 安装

> 要求
> 
> * Node.js >= v16.14

##### 自动安装

> 使用create-next-app安装，它会自动设置所有内容。
> 
> > ```shell
> > npx create-next-app@latest
> > ```
> 
> 安装时，根据提示选择。
> 
> 说明：
> 
> * Next.js默认附带TypeScript、ESLint和TailWind CSS配置。
> 
> * 你可以选择使用src目录以将应用程序的代码与配置文件分开。

#### 项目结构

> 介绍Next.js项目的文件和文件夹结构。

##### 根目录说明

* app  或 src/app    应用路由(App Router)， v13新增的功能

* pages  页面路由(Pages Router)   兼容历史版本

* public 静态资源目录

* src 可选应用程序源文件夹

**注意**

> 项目启动时默认加载的首页页面冲突问题：
> 
> 当src/app/page.tsx默认首页文件存在的时候，此页面将作为默认启动页面。如果此时在pages目录下又新建了index.tsx页面，就会和src/app/page.tsx中的页面产生冲突，导致首页无法正常加载。因此两者只存在一个即可，另外一个相关文件要删除！

#### 应用路由(App Router)

> 应用路由为v13版本新功能，应用路由基于文件系统的路由器，其中文件夹用于定义路由。每个文件夹都会映射到路由段。若要创建嵌套路由可在文件夹嵌套中完成。文件夹中的page.js,page.ts,page.tsx等是路由可公开访问的。
> 
> 例如：
> 
> /dashboard/analytics/page.js   =>   /dashboard/analytics

##### 创建首页

> 在app(或src/app)目录下，创建首页page.tsx，代码如下：

```js
export default function Page() {
  return <h1>Hello, Next.js!</h1>
}
```

对应访问路径为：/

##### 页面和布局

> Next.js 13中的应用程序路由引入了新的文件约定，可以轻松的创建页面、共享布局和模板。

**页面**

页面路由是由文件夹路径和文件夹下的page.js(page.tsx,page.ts)等构成。

例如

* app/page.tsx     =>   /

* app/dashboard/page.tsx   =>   /dashboard

**布局**

布局是可以在多个页面之间共享，在访问量，布局不能单独呈现，布局也可以嵌套。

在文件夹下创建layout.js (layout.jsx、layout.tsx)为约定的布局页面。

例如

```js
export default function DashboardLayout({
  children, // will be a page or nested layout
}: {
  children: React.ReactNode
}) {
  return (
    <section>
      {/* Include shared UI here e.g. a header or sidebar */}
      <nav></nav>

      {children}
    </section>
  )
}
```

**注意：**

* 最上面的布局称为根布局，是必须的，是所有页面共有的，根布局必须包含html、body标签。

* 任何路由段都可以定义自已的布局。这个布局将在所属下级文件夹中共享。

* 默认情况下，路由中的布局是嵌套的。每个父布局都使用React的children属性将页面包含在其中。

* 可以使用路由组选择加入和退出共享布局的特定路由段。

* 默认情况下布局是服务器组件，但可以设置为客户端组件。

* 在布局中可以获取数据。

* 无法在父布局及期子布局之间传递数据。但是可以在路由中多次获取相同数据，React会自动删除重复的数据，而不影响性能。

* 布局无权访问其下方的路径段。要访问所有路由段，可以客户端组件中使用[`useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)或[`useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)。

* .js、.jsx、tsx都可以用于布局文件

**根布局(必须)**

> 根布局在目录的顶层定义，并应用于所有路由。通过此布局，可以修改从服务器返回的初始html

代码示例(app/layout.tsx)：

```js
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

* 该布局必须在app根目录下

* 该布局必须包含html、body标签

* 可以使用路由组创建多个根布局。

##### 嵌套布局

> 在文件夹中定义的布局适用当前特定的路由段，并在这些路由段中进行渲染。默认情况下，文件夹层次结构中的布局是嵌套的，这意味着它们通过参数prop来包装子布局。

例如 app/dashboard/layout.tsx

```js
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```

如果要组合上述两个布局，则根布局将把dashboard/layout.tsx当子组件，包装在其中，嵌套顺序为

app/layout.tsx  => /app/dashboard/layout.tsx  =>  /app/dashboard/*

可以使用路由组选择加入和退出共享布局的特定的路由段。

##### 模板

> 模板与布局类似，因为它们包装每个子布局或页面。与布局不同，模板在而面上为每个子级创建一个新的实例。这意味着，当用户在共享模板的路由之间导航时，将装载新的组件实例，重新创建DOM元素，不保留状态，并重新同步效果。





#### 页面路由(Pages  Router)

> 在next.js中，路由是根据目录和文件名与路由相关联，本章节，主要讲解pages页面路由的路由规则，如果之前使用过next.js，本章可跳过。

例如：文件：pages/about.js，对应的路由为/about

```js
export default function About() {
  return <div>About</div>
}
```

##### 索引路由

> 根据文件名自动索引路由，例如
> 
> * pages/index.js   =>       /
> 
> * pages/blog/index.js  =>   /blog

##### 嵌套路由

> 路由支持多层嵌套，多层文件夹时，路由自动识别和匹配。
> 
> * pages/blog/first-post.js   =>   /blog/first-post
> 
> * pages/dashboard/settings/usename.js  =>  /dashboard/settings/usename

##### 动态路由

> Next.js 支持具有动态路由的页面。例如
> 
> * pages/post/[id].js   =>   /posts/1   posts/2

##### 布局模式

> 基于React的布局，例如页面的导航栏和页脚。

```js
import Navbar from './navbar'
import Footer from './footer'

export default function Layout({ children }) {
  return (
    <>
      <Navbar />
      <main>{children}</main>
      <Footer />
    </>
  )
}
```

#### 应用路由和页面路由的区别

| 特点       | 应用路由(App Router) | 页面路由(Pages Router) |
| -------- | ---------------- | ------------------ |
| 路由类型     | 默认服务器组件          | 默认客户端组件            |
| 支持服务器组件  | 是                | 没有                 |
| 复杂性      | 更复杂              | 更简单                |
| 性能       | 更好               | 一般                 |
| 扩展性(灵活性) | 更好               | 不太好                |

#### Next.js 13两种路由渲染方式

##### SSR

**app路由**

在app路由下，只要我们的组件是使用 async进行了修饰，都会默认开启SSR。

```js
export default async function PokemonName({ params }: { params: { name: string } }) {
  const { name } = params;

  const res = (await fetch('http://localhost:3000/api/pokemon?name=' + name)) as any;
  const resdata = await res.json();
  const { data } = resdata;

  return (
      //...
  );
}
```

**pages路由**

在pages路由下，如果要开启SSR，需要实现 getServerSideProps 这个API，在请求页面的时候，提前获取到数据，然后传入组件中。

```js
export async function getServerSideProps(context: any) {
  const data = await getPokemon(null, context.params.name);
  return {
    props: {
      data: data,
    },
  };
}

const PokemonName = ({ data }: any) => {

  return (
        //...
  );
};
```

##### SSG

> SSG生成静态站点，在构建时生成静态页面。

**app路由**
