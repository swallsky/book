## Node.js  基础篇

### REPL(交互解释器)

> Node.js REPL(Read Eval Print Loop: 交互解释器)类似Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。
> 
> Node自带了交互式解释器，可以执行以下任务：

* 读取    读取用户输入，解析输入的Javascript数据结构并存储在内存中。

* 执行    执行输入的数据结构。

* 打印    输出结果。

* 循环    循环操作以上步骤到用户两次按ctrl+c按钮退出。   

打开终端，输入node,即可进入REPL交互解释器。

```shell
$ node
> 
```

这里就可以在>后输入简单的表达式，回车来显示结果

例如：

```shell
$ node
> 1+4
5
```

### 回调函数

> Node.js异步编程的直接体现就是回调。异步编程依托回调来实现，但不能说使用了回调后程序就是异步化了。
> 
> 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。
> 
> 例如： 一边读取文件，一边执行其他的命令，在文件读取完成后，将文件内容作为回调函数的参数返回，这样在执行代码时就没有阻塞或等待文件I/O操作。这就大大提高了Node.js的性能，可以处理大量的并发请求。

异步代码实例：

```js
const fs = require("fs");

// 文件读取后，异步执行处理
fs.readFile("test.txt",function(err,data){
    if(err) return console.error(err);
    console.log(data.toString());
});
```

### 事件驱动编程

> 事件驱动编程是一种编程范式，其中程序的执行流程取决于事件的发生和处理。在传统的命令式编中，程序按照预定的顺序依次执行。而在事件驱动编程中，程序通过监听事件来相应的触发回调函数来执行。这种模式可以提高并发性和可扩展性，尤其适用于大量并发请求的情况。

#### 1. EventEmitter

> EventEmitter是Node.js中内置的一个核心模块。
> 
> Node.js所有的异步I/O操作在完成时都会发送一个事件到事件队列。
> 
> Node.js里面的许多对象都会分发事件：
> 
> * 一个net.Server对象会在每次有新连接时触发一件事件。
> 
> * 一个fs.readStream对象会在文件被打开时触发一个事件。
> 
> * ...
> 
> 所有这些产生事件的对象都是events.EventEmitter的实例。

常用的方法：

* on(event, listener)：注册一个事件监听器，当事件被触发时执行回调函数。

* emit(event, [args])：触发事件，并将可选参数传递给事件监听器。

* removeListener(event, listener)：移除指定事件的监听器。

* once(event, listener)：注册一个一次性的事件监听器，该监听器在触发一次后将被移除。

#### 2.事件循环

> Node.js使用事件循环来管理事件的触发和回调函数的执行，事件循环是一个持续运行的进程，它等待事件的触发并调用相应的回调函数。

> 事件循环的主要组成部分：
> 
> * 事件触发器（Event Triggers）：发射事件的对象，可以是 Node.js 的核心模块、自定义对象或第三方模块。
> 
> * 事件队列（Event Queue）：存储待处理事件的队列。当事件被触发时，相关的回调函数会被添加到事件队列中。
> 
> * 事件处理器（Event Handlers）：从事件队列中取出事件及其回调函数，并执行回调函数。
> 
> * 事件循环（Event Loop）：负责不断事件队列中获取事件，并将其分发给对应的事件处理器进行处理。

事件循环图如下：

![](./imgs/event_loop.jpg) 

#### 3. 实例代码:

代码文件：event-emitter.js

```js
// 引入events内置模块
const events = require("events");
// 创建一个eventEitter对象
const eventEmitter = new events.EventEmitter();

// 创建事件处理程序
const connectHandler = function connected(){
    console.log("连接成功");
};

// 绑定一个connect事件处理程序
eventEmitter.on("connect",connectHandler);

// 触发connect事件
eventEmitter.emit("connect");
```

多个事件处理实例：

代码文件：event-emitter.js

```js
// 引入events内置模块
const events = require("events");
// 创建一个eventEitter对象
const eventEmitter = new events.EventEmitter();

// 创建事件处理程序
const connectHandler = function connected(){
    console.log("连接成功");

    // 解发另一个数据获取处理事件
    eventEmitter.emit("data_received");
};

// 绑定一个connect事件处理程序
eventEmitter.on("connect",connectHandler);

// 使用匿名函数版定 data_received事件
eventEmitter.on("data_received",function(){
    console.log("数据接收成功。");
});

// 触发connect事件
eventEmitter.emit("connect");
```

带参数的事件处理实例：

代码文件：event-emitter-arg.js

```js
const events = require("events");
const eventEmitter = new events.EventEmitter();

eventEmitter.on("someEvent",function(arg1,arg2){
    console.log("listener1",arg1,arg2);
});

eventEmitter.emit("someEvent","arg1参数","arg2参数");
```
